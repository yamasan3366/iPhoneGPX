<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>iPhone GPX Viewer</title>
    <base href="./" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" />
    <link href="css/app.css" rel="stylesheet" />
</head>
<body style="position: fixed; width: 100%; height: 100%; overflow: hidden;">
    <div id="app">読み込み中...</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="_framework/blazor.webassembly.js"></script>

    <script>
        let map, userMarker, currentWalkPolyline;
        let watchId = null;

        window.initMap = () => {
            if (map) return;
            // 明示的にコンテナの存在を確認してから初期化
            const container = document.getElementById('map');
            if (!container) return;

            map = L.map('map', { zoomControl: false, center: [35.68, 139.76], zoom: 13 });
            L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
                attribution: '国土地理院'
            }).addTo(map);

            userMarker = L.circleMarker([0, 0], {
                radius: 10, color: 'white', fillColor: '#007bff', fillOpacity: 1, weight: 3
            }).addTo(map);

            // 描画バグ対策: 起動直後にサイズを再計算
            setTimeout(() => { map.invalidateSize(); }, 500);
        };

        window.showCurrentLocation = () => {
            navigator.geolocation.getCurrentPosition(pos => {
                const loc = [pos.coords.latitude, pos.coords.longitude];
                map.setView(loc, 15);
                userMarker.setLatLng(loc);
                map.invalidateSize();
            }, null, { enableHighAccuracy: true });
        };



        // グローバル変数を整理
        let lastLat = null, lastLon = null;
        window.isHeadUpInternal = false;

        window.setHeadingMode = (isHeadUp) => {
            window.isHeadUpInternal = isHeadUp;
            if (!isHeadUp) {
                map.setBearing(0); // 確実に北に向ける
            }
            return isHeadUp;
        };

        window.startTracking = (dotNetObj) => {
            if (watchId) return;
            currentWalkPolyline = L.polyline([], { color: 'blue', weight: 6 }).addTo(map);

            watchId = navigator.geolocation.watchPosition(pos => {
                const lat = pos.coords.latitude;
                const lon = pos.coords.longitude;
                const ele = pos.coords.altitude || 0;

                // 1. 地図の回転処理（ヘッドアップ時）
                if (window.isHeadUpInternal && lastLat !== null) {
                    const r = Math.PI / 180;
                    const dLon = (lon - lastLon) * r;
                    const lat1 = lastLat * r;
                    const lat2 = lat * r;

                    const y = Math.sin(dLon) * Math.cos(lat2);
                    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
                    const bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;

                    // 移動距離が極端に短い時のチャタリング防止（簡易的）
                    if (Math.abs(lat - lastLat) > 0.00001 || Math.abs(lon - lastLon) > 0.00001) {
                        map.setBearing(bearing);
                    }
                }

                // 2. 地図の自動スクロール（現在地を中央に）
                map.setView([lat, lon]);
                userMarker.setLatLng([lat, lon]);
                currentWalkPolyline.addLatLng([lat, lon]);

                // 3. 重要：前回の位置を保存（次回の回転計算用）
                lastLat = lat;
                lastLon = lon;

                // 4. Blazor側へデータを送る（これでログが記録される）
                dotNetObj.invokeMethodAsync('OnLocationUpdated', {
                    lat: lat,
                    lon: lon,
                    ele: ele
                });

            }, err => console.error(err), { enableHighAccuracy: true, maximumAge: 1000 });
        };

        window.stopTracking = () => {
            if (watchId) { navigator.geolocation.clearWatch(watchId); watchId = null; }
        };

        window.clearWalkPolyline = () => {
            map.eachLayer(layer => {
                if (layer instanceof L.Polyline && layer.options.color === 'blue') map.removeLayer(layer);
            });
        };

        window.drawTrack = (pts) => {
            if (!pts || pts.length === 0) return;
            map.eachLayer(layer => {
                if (layer instanceof L.Polyline && layer.options.color === 'red') map.removeLayer(layer);
            });
            const latlngs = pts.map(p => [p.lat, p.lon]);
            // dashArrayを削除して実線に
            const route = L.polyline(latlngs, { color: 'red', weight: 4 }).addTo(map);

            setTimeout(() => {
                map.invalidateSize();
                map.fitBounds(route.getBounds(), { padding: [40, 40] });
            }, 200);
        };

        window.downloadFile = (fileName, content) => {
            const blob = new Blob([content], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = fileName;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 200);
        };
    </script>
</body>
</html>